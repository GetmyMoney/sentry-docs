## Thread Safety

Be careful when spawning operations as independent threads or asynchronous tasks.

APIs provided by the SDK are not inherently thread-safe. Several constructors will contain a warning regarding thread-safety in their docstrings. Functions that operate on the return values of such constructors will also mention any locking requirements.

For example, the documentation of `sentry_transaction_context_new()`, which constructs a `sentry_transaction_context_t`, includes a warning in its final paragraph:

```c
/**
 * Constructs a new Transaction Context. The returned value needs to be passed
 * into `sentry_transaction_start` in order to be recorded and sent to sentry.
 *
 * [...]
 *
 * The returned value is not thread-safe. Users are expected to ensure that
 * appropriate locking mechanisms are implemented over the Transaction Context
 * if it needs to be mutated across threads. Methods operating on the
 * Transaction Context will mention what kind of expectations they carry if they
 * need to mutate or access the object in a thread-safe way.
 */

```

Following up on that warning, `sentry_transaction_context_set_name()`, which operates on a `sentry_transaction_context_t`, notes that it requires a lock:

```c
/**
 * Sets the `name` on a Transaction Context, which will be used in the
 * Transaction constructed off of the context.
 *
 * The Transaction Context should not be mutated by other functions while
 * setting a name on it.
 */

```

While you can use scopes to work with concurrency on other platforms, this isn't the case for the native SDK. This, as well as the what you can expect if you add manual instrumentation to your app using the native, is discussed in the following two sections.

### Single Scope, Multiple Transactions

The native SDK makes a major compromise in an attempt to follow a server-like model despite having a single scope: A user may create multiple concurrent transactions and multiple concurrent spans, at the cost of making it their responsibility to manage the transactions and spans. It is on them to ensure that no unsafe mutations are being made to transactions while they are being used. In comparison, other SDKs either follow a single (hidden) scope, single transaction model where all spans across multiple threads are collapsed into one single transaction.

Currently, the SDK doesn't support associating events with specific spans or transactions in a multi-threaded environment. All events will be linked to the single span or transaction that is set through `sentry_set_span` or `sentry_set_transaction_object`.

### Spans on the Scope

Unlike the Python SDK, if a transaction or a span is on the scope, any new child spans spun off of that will **not** update the scope to point to the newly created span.

You must manually set spans on the scope if you're are interested in associating events (errors, messages) with a specific span. To fully mimic the Python SDKâ€™s behaviour, you need to manually set spans, and re-set parent spans and/or transactions on the scope when a child span finishes. Note that since there is a single global scope in the native SDK, there is a possibility that an event may be associated with the wrong span in a multi-threaded environment.